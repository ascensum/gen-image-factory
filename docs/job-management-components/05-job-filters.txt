JobFilters Component Specification

Component Overview
The JobFilters component provides advanced filtering and search capabilities for the Job Management system. It includes status filters, date range selection, configuration filtering, and full-text search with real-time filtering and filter persistence.

Component Structure

File Location
src/renderer/components/Jobs/JobFilters.tsx

Component Hierarchy
JobFilters
├── FilterHeader
├── FilterControls
│   ├── StatusFilter
│   ├── DateRangeFilter
│   ├── ConfigurationFilter
│   └── SearchFilter
├── FilterSummary
├── FilterPresets
└── ClearFiltersButton

Props Interface

interface JobFiltersProps {
  filters: JobFilters;
  onFiltersChange: (filters: JobFilters) => void;
  onClearFilters: () => void;
  availableConfigurations: JobConfiguration[];
  isLoading: boolean;
  className?: string;
}

interface JobFilters {
  status: 'all' | 'completed' | 'failed' | 'running' | 'stopped' | 'pending';
  dateRange: {
    from: Date | null;
    to: Date | null;
  };
  configuration: string | 'all';
  search: string;
  sortBy: 'startedAt' | 'completedAt' | 'duration' | 'totalImages' | 'configurationName';
  sortOrder: 'asc' | 'desc';
}

State Management

Local State
const [isDatePickerOpen, setIsDatePickerOpen] = useState(false);
const [datePickerMode, setDatePickerMode] = useState<'from' | 'to'>('from');
const [searchDebounceTimer, setSearchDebounceTimer] = useState<NodeJS.Timeout | null>(null);
const [filterPresets, setFilterPresets] = useState<FilterPreset[]>([]);
const [showPresetMenu, setShowPresetMenu] = useState(false);
const [presetName, setPresetName] = useState('');
const [showSavePreset, setShowSavePreset] = useState(false);

Derived State
const hasActiveFilters = useMemo(() => {
  return filters.status !== 'all' ||
         filters.dateRange.from !== null ||
         filters.dateRange.to !== null ||
         filters.configuration !== 'all' ||
         filters.search.trim() !== '';
}, [filters]);

const activeFilterCount = useMemo(() => {
  let count = 0;
  if (filters.status !== 'all') count++;
  if (filters.dateRange.from !== null) count++;
  if (filters.dateRange.to !== null) count++;
  if (filters.configuration !== 'all') count++;
  if (filters.search.trim() !== '') count++;
  return count;
}, [filters]);

Component Layout

Filter Structure
Advanced Filters & Search Bar
┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐
│ Status      │ │ Date Range  │ │ Config     │ │ Search Jobs...      │
│ [Dropdown]  │ │ [Date Picker]│ │ [Dropdown] │ │ [Search Input]      │
└─────────────┘ └─────────────┘ └─────────────┘ └─────────────────────┘

Filter Summary: 3 active filters
[Save as Preset] [Clear All Filters]

Filter Presets: [Recent Searches] [Saved Filters]
[Quick Filter 1] [Quick Filter 2] [Quick Filter 3]

Layout Sections

Filter Controls Row
- Status Filter: Dropdown with status options
- Date Range Filter: Date picker with from/to inputs
- Configuration Filter: Dropdown with available configurations
- Search Input: Full-text search with debounced input

Filter Summary Row
- Active Filter Count: Shows number of active filters
- Save Preset Button: Save current filter combination
- Clear All Button: Reset all filters to default

Filter Presets Row
- Recent Searches: Quick access to recent filter combinations
- Saved Filters: User-defined filter presets
- Quick Filters: Common filter combinations

Key Features

Status Filtering
- Status Options: All, Completed, Failed, Running, Stopped, Pending
- Multi-select Support: Allow multiple status selection
- Visual Indicators: Color-coded status badges
- Status Counts: Show count of jobs for each status

Date Range Filtering
- Date Picker: Calendar popup for date selection
- From/To Inputs: Separate inputs for start and end dates
- Date Validation: Ensure from date is before to date
- Quick Ranges: Preset ranges (Today, Last 7 days, Last 30 days, etc.)

Configuration Filtering
- Configuration Dropdown: List of available job configurations
- Search Within: Search within configuration names
- Recent Configurations: Show recently used configurations first
- Configuration Details: Show configuration description on hover

Search Functionality
- Full-text Search: Search across job names, IDs, and descriptions
- Debounced Input: Prevent excessive API calls during typing
- Search Highlighting: Highlight search terms in results
- Search History: Remember recent search terms

Filter Presets
- Save Presets: Save current filter combinations
- Load Presets: Quick access to saved filter combinations
- Preset Management: Edit, rename, and delete presets
- Preset Sharing: Export/import filter presets

Event Handlers

Filter Change Events
const handleStatusChange = (status: JobFilters['status']) => {
  onFiltersChange({
    ...filters,
    status
  });
};

const handleDateRangeChange = (dateRange: JobFilters['dateRange']) => {
  onFiltersChange({
    ...filters,
    dateRange
  });
};

const handleConfigurationChange = (configuration: string) => {
  onFiltersChange({
    ...filters,
    configuration
  });
};

const handleSearchChange = (search: string) => {
  // Clear existing timer
  if (searchDebounceTimer) {
    clearTimeout(searchDebounceTimer);
  }

  // Set new timer for debounced search
  const timer = setTimeout(() => {
    onFiltersChange({
      ...filters,
      search
    });
  }, 300);

  setSearchDebounceTimer(timer);
};

const handleSortChange = (sortBy: JobFilters['sortBy']) => {
  const currentOrder = filters.sortBy === sortBy ? filters.sortOrder : 'desc';
  const newOrder = currentOrder === 'asc' ? 'desc' : 'asc';
  
  onFiltersChange({
    ...filters,
    sortBy,
    sortOrder: newOrder
  });
};

Filter Management Events
const handleClearFilters = () => {
  onClearFilters();
  setShowSavePreset(false);
  setPresetName('');
};

const handleSavePreset = () => {
  if (!presetName.trim()) return;
  
  const newPreset: FilterPreset = {
    id: Date.now().toString(),
    name: presetName.trim(),
    filters: { ...filters },
    createdAt: new Date(),
    isDefault: false
  };
  
  setFilterPresets(prev => [...prev, newPreset]);
  setShowSavePreset(false);
  setPresetName('');
  
  // Save to localStorage
  localStorage.setItem('jobFilterPresets', JSON.stringify([...filterPresets, newPreset]));
};

const handleLoadPreset = (preset: FilterPreset) => {
  onFiltersChange(preset.filters);
};

const handleDeletePreset = (presetId: string) => {
  setFilterPresets(prev => prev.filter(p => p.id !== presetId));
  
  // Update localStorage
  const updatedPresets = filterPresets.filter(p => p.id !== presetId);
  localStorage.setItem('jobFilterPresets', JSON.stringify(updatedPresets));
};

Filter Components

Status Filter Dropdown
const StatusFilter: React.FC<{
  value: JobFilters['status'];
  onChange: (status: JobFilters['status']) => void;
}> = ({ value, onChange }) => {
  const statusOptions = [
    { value: 'all', label: 'All Statuses', color: 'gray' },
    { value: 'completed', label: 'Completed', color: 'green' },
    { value: 'failed', label: 'Failed', color: 'red' },
    { value: 'running', label: 'Running', color: 'blue' },
    { value: 'stopped', label: 'Stopped', color: 'yellow' },
    { value: 'pending', label: 'Pending', color: 'orange' }
  ];

  return (
    <div className="relative">
      <select
        value={value}
        onChange={(e) => onChange(e.target.value as JobFilters['status'])}
        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
      >
        {statusOptions.map(option => (
          <option key={option.value} value={option.value}>
            {option.label}
          </option>
        ))}
      </select>
    </div>
  );
};

Date Range Filter
const DateRangeFilter: React.FC<{
  dateRange: JobFilters['dateRange'];
  onChange: (dateRange: JobFilters['dateRange']) => void;
}> = ({ dateRange, onChange }) => {
  const quickRanges = [
    { label: 'Today', from: new Date(), to: new Date() },
    { label: 'Last 7 days', from: subDays(new Date(), 7), to: new Date() },
    { label: 'Last 30 days', from: subDays(new Date(), 30), to: new Date() },
    { label: 'This month', from: startOfMonth(new Date()), to: endOfMonth(new Date()) },
    { label: 'Last month', from: startOfMonth(subMonths(new Date(), 1)), to: endOfMonth(subMonths(new Date(), 1)) }
  ];

  const handleQuickRange = (range: typeof quickRanges[0]) => {
    onChange({
      from: range.from,
      to: range.to
    });
  };

  return (
    <div className="relative">
      <div className="flex gap-2">
        <div className="relative">
          <input
            type="text"
            placeholder="From Date"
            value={dateRange.from ? format(dateRange.from, 'MMM dd, yyyy') : ''}
            onClick={() => {
              setDatePickerMode('from');
              setIsDatePickerOpen(true);
            }}
            readOnly
            className="w-32 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 cursor-pointer"
          />
        </div>
        
        <div className="relative">
          <input
            type="text"
            placeholder="To Date"
            value={dateRange.to ? format(dateRange.to, 'MMM dd, yyyy') : ''}
            onClick={() => {
              setDatePickerMode('to');
              setIsDatePickerOpen(true);
            }}
            readOnly
            className="w-32 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 cursor-pointer"
          />
        </div>
      </div>

      {/* Quick Range Buttons */}
      <div className="mt-2 flex flex-wrap gap-1">
        {quickRanges.map(range => (
          <button
            key={range.label}
            onClick={() => handleQuickRange(range)}
            className="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 rounded transition-colors"
          >
            {range.label}
          </button>
        ))}
      </div>

      {/* Date Picker Modal */}
      {isDatePickerOpen && (
        <DatePickerModal
          mode={datePickerMode}
          date={datePickerMode === 'from' ? dateRange.from : dateRange.to}
          onDateSelect={(date) => {
            onChange({
              ...dateRange,
              [datePickerMode]: date
            });
            setIsDatePickerOpen(false);
          }}
          onClose={() => setIsDatePickerOpen(false)}
        />
      )}
    </div>
  );
};

Configuration Filter
const ConfigurationFilter: React.FC<{
  value: string;
  configurations: JobConfiguration[];
  onChange: (configuration: string) => void;
}> = ({ value, configurations, onChange }) => {
  const [searchTerm, setSearchTerm] = useState('');
  
  const filteredConfigurations = useMemo(() => {
    if (!searchTerm) return configurations;
    return configurations.filter(config => 
      config.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      (config.description && config.description.toLowerCase().includes(searchTerm.toLowerCase()))
    );
  }, [configurations, searchTerm]);

  return (
    <div className="relative">
      <select
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
      >
        <option value="all">All Configurations</option>
        {filteredConfigurations.map(config => (
          <option key={config.id} value={config.id}>
            {config.name}
          </option>
        ))}
      </select>
      
      {/* Search within configurations */}
      <div className="mt-2">
        <input
          type="text"
          placeholder="Search configurations..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="w-full px-2 py-1 text-sm border border-gray-200 rounded focus:outline-none focus:ring-1 focus:ring-blue-500"
        />
      </div>
    </div>
  );
};

Search Filter
const SearchFilter: React.FC<{
  value: string;
  onChange: (search: string) => void;
  placeholder?: string;
}> = ({ value, onChange, placeholder = "Search jobs..." }) => {
  const [localValue, setLocalValue] = useState(value);
  
  useEffect(() => {
    setLocalValue(value);
  }, [value]);

  const handleChange = (newValue: string) => {
    setLocalValue(newValue);
    handleSearchChange(newValue);
  };

  return (
    <div className="relative">
      <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
        <svg className="h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
        </svg>
      </div>
      
      <input
        type="text"
        value={localValue}
        onChange={(e) => handleChange(e.target.value)}
        placeholder={placeholder}
        className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
      />
      
      {localValue && (
        <button
          onClick={() => handleChange('')}
          className="absolute inset-y-0 right-0 pr-3 flex items-center"
        >
          <svg className="h-5 w-5 text-gray-400 hover:text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      )}
    </div>
  );
};

Filter Presets Management

Preset Interface
interface FilterPreset {
  id: string;
  name: string;
  filters: JobFilters;
  createdAt: Date;
  isDefault: boolean;
  usageCount: number;
  lastUsed?: Date;
}

Preset Components
const FilterPresets: React.FC<{
  presets: FilterPreset[];
  onLoadPreset: (preset: FilterPreset) => void;
  onDeletePreset: (presetId: string) => void;
  onSavePreset: () => void;
}> = ({ presets, onLoadPreset, onDeletePreset, onSavePreset }) => {
  const recentPresets = presets
    .filter(p => p.lastUsed)
    .sort((a, b) => (b.lastUsed?.getTime() || 0) - (a.lastUsed?.getTime() || 0))
    .slice(0, 3);

  const savedPresets = presets.filter(p => !p.isDefault);

  return (
    <div className="mt-4">
      {/* Recent Presets */}
      {recentPresets.length > 0 && (
        <div className="mb-3">
          <h4 className="text-sm font-medium text-gray-700 mb-2">Recent Searches</h4>
          <div className="flex flex-wrap gap-2">
            {recentPresets.map(preset => (
              <button
                key={preset.id}
                onClick={() => onLoadPreset(preset)}
                className="px-3 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-800 rounded-full transition-colors"
              >
                {preset.name}
              </button>
            ))}
          </div>
        </div>
      )}

      {/* Saved Presets */}
      {savedPresets.length > 0 && (
        <div className="mb-3">
          <h4 className="text-sm font-medium text-gray-700 mb-2">Saved Filters</h4>
          <div className="flex flex-wrap gap-2">
            {savedPresets.map(preset => (
              <div key={preset.id} className="flex items-center gap-1">
                <button
                  onClick={() => onLoadPreset(preset)}
                  className="px-3 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-800 rounded-full transition-colors"
                >
                  {preset.name}
                </button>
                <button
                  onClick={() => onDeletePreset(preset.id)}
                  className="text-gray-400 hover:text-red-500 transition-colors"
                >
                  <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Save Current Preset */}
      <button
        onClick={onSavePreset}
        className="px-3 py-1 text-xs bg-green-100 hover:bg-green-200 text-green-800 rounded-full transition-colors"
      >
        Save Current Filters
      </button>
    </div>
  );
};

Filter Summary

Summary Component
const FilterSummary: React.FC<{
  activeFilterCount: number;
  onClearFilters: () => void;
  onSavePreset: () => void;
}> = ({ activeFilterCount, onClearFilters, onSavePreset }) => {
  if (activeFilterCount === 0) return null;

  return (
    <div className="mt-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2 text-blue-800">
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.414A1 1 0 013 6.707V4z" />
          </svg>
          <span className="text-sm font-medium">
            {activeFilterCount} active filter{activeFilterCount !== 1 ? 's' : ''}
          </span>
        </div>
        
        <div className="flex gap-2">
          <button
            onClick={onSavePreset}
            className="px-3 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-800 rounded transition-colors"
          >
            Save as Preset
          </button>
          <button
            onClick={onClearFilters}
            className="px-3 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-800 rounded transition-colors"
          >
            Clear All
          </button>
        </div>
      </div>
    </div>
  );
};

Performance Optimizations

Debounced Search
- Search Debouncing: 300ms delay to prevent excessive API calls
- Input Optimization: Local state for immediate UI feedback
- Timer Management: Proper cleanup of debounce timers

Memoization
- Filtered Results: Memoize filtered configuration lists
- Active Filter Count: Memoize filter count calculations
- Event Handlers: Memoize event handler functions

Filter Persistence
- Local Storage: Save filter presets to localStorage
- Filter State: Persist current filter state across sessions
- Preset Management: Efficient preset loading and saving

Accessibility Features

Keyboard Navigation
- Tab Order: Logical tab order through all filter controls
- Enter/Space: Activate dropdowns and buttons
- Arrow Keys: Navigate dropdown options
- Escape: Close dropdowns and modals

Screen Reader Support
- ARIA Labels: Proper labeling for all filter controls
- Filter Descriptions: Clear descriptions of active filters
- Status Announcements: Announce filter changes and results
- Preset Information: Accessible preset management

Visual Accessibility
- Color Contrast: Meet WCAG contrast requirements
- Focus Indicators: Clear focus states for all controls
- Filter States: Clear visual indicators for active filters
- Error States: Clear visual indicators for validation errors

Testing Requirements

Unit Tests
- Component Rendering: Test component renders correctly with different props
- Filter Logic: Test filter application and validation
- Event Handling: Test all event handlers and callbacks
- Preset Management: Test preset saving, loading, and deletion

Integration Tests
- Data Flow: Test data flow between components
- Filter Updates: Test filter changes and propagation
- Preset Operations: Test preset management workflows
- Search Functionality: Test search and debouncing

E2E Tests
- Filter Workflows: Test complete filtering workflows
- Preset Management: Test preset operations and persistence
- Search Experience: Test search functionality and performance
- Accessibility: Test keyboard navigation and screen reader support

Styling Guidelines

Tailwind Classes
- Layout: Use flexbox and grid for filter layout
- Spacing: Use consistent spacing scale (4px increments)
- Colors: Use established color palette from design system
- Typography: Use consistent font sizes and weights
- Shadows: Use subtle shadows for depth and hierarchy

Desktop Design
- Desktop First: Optimize for 1200px+ filter width
- Window Resizing: Flexible filter layout for different desktop resolutions
- Desktop Interactions: Mouse, keyboard, and trackpad optimized
- Native OS Integration: Leverage platform-specific filter behavior

Future Enhancements

Planned Features
- Advanced Search: AI-powered search suggestions
- Filter Analytics: Track filter usage and effectiveness
- Smart Presets: Auto-generate presets based on usage patterns
- Filter Sharing: Share filter combinations with team members

Technical Improvements
- Real-time Filtering: Instant filter results without API calls
- Filter Caching: Cache filter results for better performance
- Advanced Date Ranges: Relative date ranges and custom periods
- Filter Export: Export filter configurations for backup

Conclusion

The JobFilters component provides a comprehensive and efficient interface for filtering and searching job data. By implementing advanced filtering capabilities, filter presets, and real-time search, it delivers a professional user experience while maintaining performance and accessibility.

The component's focus on user experience and filter management ensures users can effectively find and organize job data, while the modular architecture ensures maintainability and extensibility for future enhancements.
